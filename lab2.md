# JOS-operating-system

## Lab 2: Memory Management

* This lab is about memory management. Memory management has two components. 

  *  The first component is a `physical memeory allocator` for the kernel, so that the kernel can allocate memory and later free it. The allocator will operate in units of 4096 bytes, called pages. The task will be to maintain data structures that record which physical pages are free and which are allocated, and how many processes are sharing each allocated page. You will also write the routines to allocate and free pages of memory.

  *  The second component of memory management is `virtual memory`, which maps the virtual addresses used by kernel and user software to addresses in physical memory. The x86 hardware's memory management unit (MMU) performs the mapping when instructions use memory, consulting a set of page tables. You will modify JOS to set up the MMU's page tables according to a specification we provide.

* Lab 2 contains the following new source files, which you should browse through:

  inc/memlayout.h
  
  kern/pmap.c
  
  kern/pmap.h
  
  kern/kclock.h
  
  kern/kclock.c

  *  *memlayout.h* describes the layout of the virtual address space that you must implement by modifying pmap.c. 

  *  *memlayout.h* and pmap.h define the PageInfo structure that you'll use to keep track of which pages of physical memory are free. 

  *  *kclock.c* and *kclock.h* manipulate the PC's battery-backed clock and CMOS RAM hardware, in which the BIOS records the amount of physical memory the PC contains, among other things. The code in pmap.c needs to read this device hardware in order to figure out how much physical memory there is, but that part of the code is done for you: you do not need to know the details of how the CMOS hardware works.

### Part 1: Physical Page Management

The operating system must keep track of which parts of physical RAM are free and which are currently in use. JOS manages the PC's physical memory with page granularity so that it can use the MMU to map and protect each piece of allocated memory.

You'll now write the physical page allocator. It keeps track of which pages are free with a linked list of struct PageInfo objects (which, unlike xv6, are not embedded in the free pages themselves), each corresponding to a physical page.

#### Exercise 1.

>In the file kern/pmap.c, you must implement code for the following functions (probably in the order given). 

>boot_alloc()

>mem_init() (only up to the call to check_page_free_list(1))

>page_init()

>page_alloc() 

>page_free(). 

>check_page_free_list() and check_page_alloc() test your physical page allocator. You should boot JOS and see whether check_page_alloc() reports success. Fix your code so that it passes. You may find it helpful to add your own assert()s to verify that your assumptions are correct.

* boot_alloc() is called in mem_init() and page_init(). It keeps track of the front address of allocated pages during initialization. After initialization, it is never called again, and page allocations are managed by page allocator functions. Related codes in mem_init() are:
	```{r}
	//create initial page directory
	kern_pgdir = (pde_t \*) boot_alloc(PGSIZE); 
	memset(kern_pgdir, 0, PGSIZE);
	```


	boot_alloc():
	```{r}
	// This simple physical memory allocator is used only while JOS is setting
	// up its virtual memory system.  page_alloc() is the real allocator.
	//
	// If n>0, allocates enough pages of contiguous physical memory to hold 'n'
	// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.
	//
	// If n==0, returns the address of the next free page without allocating
	// anything.
	//
	// If we're out of memory, boot_alloc should panic.
	// This function may ONLY be used during initialization,
	// before the page_free_list list has been set up.
	static void *
	boot_alloc(uint32_t n)
	{
		static char *nextfree;	// virtual address of next byte of free memory
		char *result;

		// Initialize nextfree if this is the first time.
		// 'end' is a magic symbol automatically generated by the linker,
		// which points to the end of the kernel's bss segment:
		// the first virtual address that the linker did *not* assign
		// to any kernel code or global variables.
		if (!nextfree) {
			extern char end[];
			nextfree = ROUNDUP((char *) end, PGSIZE);
		}

		// Allocate a chunk large enough to hold 'n' bytes, then update
		// nextfree.  Make sure nextfree is kept aligned
		// to a multiple of PGSIZE.
		//
		// LAB 2: Your code here.

		result = nextfree;
		if(n > 0){
			nextfree = ROUNDUP(nextfree + n, PGSIZE);
		}
		if((uint32_t)nextfree  - KERNBASE > npages * PGSIZE){
			panic("boot_alloc: Out of memory!\n");
		}
		return result;
	}
	```

* The code we need to implement in mem_init() is to allocate an array to store each pageâ€˜s information.

	mem_init():
	```{r}
	//////////////////////////////////////////////////////////////////////
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.  Use memset
	// to initialize all fields of each struct PageInfo to 0.
	// Your code goes here:
	pages = (struct PageInfo*) boot_alloc(npages * sizeof(struct PageInfo));
	memset(pages, 0, npages * sizeof(struct PageInfo));
	```
* page_init() marks pages in base memory and unallocated extend memory as free. A free page linked list data structure is used here.

	page_init();
	```{r}
	// --------------------------------------------------------------
	// Tracking of physical pages.
	// The 'pages' array has one 'struct PageInfo' entry per physical page.
	// Pages are reference counted, and free pages are kept on a linked list.
	// --------------------------------------------------------------

	//
	// Initialize page structure and memory free list.
	// After this is done, NEVER use boot_alloc again.  ONLY use the page
	// allocator functions below to allocate and deallocate physical
	// memory via the page_free_list.
	//
	void
	page_init(void)
	{
		// The example code here marks all physical pages as free.
		// However this is not truly the case.  What memory is free?
		//  1) Mark physical page 0 as in use.
		//     This way we preserve the real-mode IDT and BIOS structures
		//     in case we ever need them.  (Currently we don't, but...)
		//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
		//     is free.
		//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
		//     never be allocated.
		//  4) Then extended memory [EXTPHYSMEM, ...).
		//     Some of it is in use, some is free. Where is the kernel
		//     in physical memory?  Which pages are already in use for
		//     page tables and other data structures?
		//
		// Change the code to reflect this.
		// NB: DO NOT actually touch the physical memory corresponding to
		// free pages!
		size_t i;
		page_free_list = null;
		pages[0].pp_ref = 1;

		for (i = 1; i < npages_basemem; i++) {
			pages[i].pp_ref = 0;
			pages[i].pp_link = page_free_list;
			page_free_list = &pages[i];
		}
		for (i = PADDR(boot_alloc(0))/PGSIZE; i < npages; i++) {
			pages[i].pp_ref = 0;
			pages[i].pp_link = page_free_list;
			page_free_list = &pages[i];
		}
	}
	```

* page_alloc() allocates a physical page from the end of the page_free_list.

	page_alloc():
	```{r}
	//
	// Allocates a physical page.  If (alloc_flags & ALLOC_ZERO), fills the entire
	// returned physical page with '\0' bytes.  Does NOT increment the reference
	// count of the page - the caller must do these if necessary (either explicitly
	// or via page_insert).
	//
	// Be sure to set the pp_link field of the allocated page to NULL so
	// page_free can check for double-free bugs.
	//
	// Returns NULL if out of free memory.
	//
	// Hint: use page2kva and memset
	struct PageInfo *
	page_alloc(int alloc_flags)
	{
		// Fill this function in
		if(page_free_list == NULL) return NULL;
		struct PageInfo *pp = page_free_list;
		page_free_list = pp->pp_link;
		pp->pp_link = NULL;
		if(alloc_flags & ALLOC_ZERO){
			memset(page2kva(pp), 0, PGSIZE);
		}
		return pp;
	}
	```
	
* page_free() puts a page into the page_free_list.

	page_free():
	```{r}
	//
	// Return a page to the free list.
	// (This function should only be called when pp->pp_ref reaches 0.)
	//
	void
	page_free(struct PageInfo *pp)
	{
		// Fill this function in
		// Hint: You may want to panic if pp->pp_ref is nonzero or
		// pp->pp_link is not NULL.
		if(pp->pp_ref != 0){
			panic("pp->pp_ref != 0.");
		}
		if(pp->pp_link != NULL){
			panic("pp->pp_link != NULL.");
		}
		pp->pp_link = page_free_list;
		page_free_list = pp;
	}
	```

### Part 2: Virtual Memory

In x86 terminology, a ```virtual address``` consists of a segment selector and an offset within the segment. A ```linear address``` is what you get after segment translation but before page translation. A ```physical address``` is what you finally get after both segment and page translation and what ultimately goes out on the hardware bus to your RAM.

The JOS kernel often needs to manipulate addresses as opaque values or as integers, without dereferencing them, for example in the physical memory allocator. Sometimes these are virtual addresses, and sometimes they are physical addresses. To help document the code, the JOS source distinguishes the two cases: the type `uintptr_t` represents opaque virtual addresses, and `physaddr_t` represents physical addresses. 

The JOS kernel can dereference a uintptr_t by first casting it to a pointer type. In contrast, the kernel can't sensibly dereference a physical address, since the MMU translates all memory references.

#### Question

> Assuming that the following JOS kernel code is correct, what type should variable x have, uintptr_t or physaddr_t?
```{r}
	mystery_t x;
	char* value = return_a_pointer();
	*value = 10;
	x = (mystery_t) value;
```

Since the kernel can only dereference a uintptr_t 
